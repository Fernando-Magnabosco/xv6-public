Arquivo de teste: code.c

    "code.c" recebe como argumento em argv[1] uma quantidade inicial de bilhetes. 
    A partir disso, o programa inicia P (declarado no próprio code.c) processos
    que executam o algoritmo bubble sort N vezes, para um vetor de SIZE elementos
    ordenados inversamente. (N e SIZE definidos em bubble.c).

A quantidade de bilhetes de cada processo é calculada desta forma:
O tamanho do passo é calculado desta forma: 

Se code recebeu argumento, então:
    Para o processo i,  passo(i) = DIVIDEND / (argv[1] + i * 10), se argv[1] + i * 10 <= MAX_TICKETS; 
                        passo(i) = DIVIDEND / MAX_TICKETS, se argv[1] + i * 10 > MAX_TICKETS.

Senão:
    Para o processo i,  passo(i) = DIVIDEND / (10 + i * 10), se 10 + i * 10 <= MAX_TICKETS; 
                        passo(i) = DIVIDEND / MAX_TICKETS, se 10 + i * 10 > MAX_TICKETS;

Sendo i o iterador do laço que inicia os processos,
            MAX_TICKETS a macro definida em proc.h,
                 que limita o máximo de bilhetes e
               DIVIDEND, também definida em proc.h, 
              pode possuir qualquer valor maior que
                                        MAX_TICKETS



Stride Scheduler:

    O algoritmo de escalonamento stride tem como diferencial a capa-
    cidade de determinizar o escalonamento. Seu funcionamento é bas-
    tante semelhante com o escalonamento por loteria, mas em vez de
    sortear um bilhete, o stride calcula o tamanho do passo de 
    determinado processo, definido por (DIVIDEND / noTickets). A par-
    tir disso, o escalonador escolhe o processo com o menor passo
    (todos começam com zero) e após a execução soma o tamanho do 
    passo ao passo do processo.





Resultado esperado:


    Semelhante ao escalonamento por loteria, espera-se que os proces-
    sos que forem iniciados por último terminem primeiro. No entan-
    to, desta vez, a ordem de execução é determinística.


